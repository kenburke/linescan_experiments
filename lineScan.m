classdef lineScan < handle
    
    properties
        name = [];
        location = [];
        time = [];
        red = [];
        green = [];
        numTrials = [];
        greenRed = [];
        peaks = [];
        stimTimes = [];
    end
        
    properties (SetAccess = private, Hidden = true)
        redRaw = [];
        greenRaw = [];
        globalScanTimes = [];
        relScanTimes = [];
        xmlData = [];
        rigParams = [];        
        analysisParams = [];    %stuff you will need to reproduce analyses
        maskedPixels = [];      %masked pixels (rows) in each frame (columns)
    end
        
    methods 
        
        %starting off
        function obj = lineScan(fullPath,containerObj)
            % make a linescan from normal Linescan folder generated by Prairie

            if nargin<2
                containerObj = 'off';
                if nargin < 1   %you're in the folder
                    fullPath = pwd;
                end
            end
            
            if isobject(containerObj)       %true when lineScan is being put into 
                                            %array of another object like bouton, so we can listen
                addlistener(containerObj,'Reset',@obj.eventReset);
                addlistener(containerObj,'SaveFigs',@obj.eventSaveFigs);
                addlistener(containerObj,'ChangeParams',@obj.eventChangeParams);
            end
            
            obj.importNameAndLoc(fullPath);
            obj.importXmlData;
            obj.importRigParams;
            obj.importImagingData;
            obj.importTimeData;
            obj.initializeDefaultAnalysis;
            
            if isobject(containerObj)
                obj.stimTimes = containerObj.stimTimes;     %to override default
            end

            disp(['     ' obj.name ' Imported']);
        end
        
        %ANALYSIS SECTION
        function normalize(this, plot_on, norm_range)
            
            if nargin<3;
                try
                    norm_range = this.analysisParams.norm_range;
                catch
                    norm_range = [0.05, 0.095]; %default time range for normalization in seconds
                    this.analysisParams.norm_range = norm_range;
                end
            else %given new value
                this.analysisParams.norm_range = norm_range;
            end
            
            if nargin<2;
                plot_on = 0; %turns off plotting by default
            end
            
            %start with green-ONLY normalization
            normGreenMat = zeros(size(this.green.sum));
            dt = this.rigParams.scanlinePeriod;
            norm_range_time = floor(norm_range./dt);

            for j=1:(size(this.green.sum,1))
                normGreenMat(j,:)=this.green.sum(j,:)./mean(this.green.sum(j,norm_range_time(1):norm_range_time(2)),2)-1;
            end

            this.green.normMat = normGreenMat;
            this.green.norm = mean(normGreenMat);

            this.green.norm_sem = std(this.green.normMat)./sqrt(this.rigParams.numFrames);
            
            %now green_over_red
            if(this.analysisParams.dgr)
                this.greenRed.sum = this.green.sum./this.red.sum;    %normalize each trial's green by red
                this.greenRed.sem = std(this.greenRed.sum)./sqrt(this.rigParams.numFrames);

                normGreenOverRedMat = zeros(size(this.greenRed.sum));

                for k=1:(size(this.greenRed.sum,1))    %normalize each trial to baseline
                    normGreenOverRedMat(k,:)=this.greenRed.sum(k,:)./mean(this.greenRed.sum(k,norm_range_time(1):norm_range_time(2)),2)-1;
                end

                this.greenRed.normMat = normGreenOverRedMat;
                this.greenRed.norm = mean(normGreenOverRedMat);
                this.greenRed.norm_sem = std(this.greenRed.normMat)./sqrt(this.rigParams.numFrames);
            end
            
            %now plot if you're interested
            if plot_on
                figure();
                hold on
                plot(this.time,(this.green.normMat'),'-','Color',[0.7 0.9 0.7]);
                shadedErrorBar(this.time,(this.green.norm),this.green.norm_sem,{'-g'},1);
                plot(this.time,(this.greenRed.normMat'),'-','Color',[0.8 0.8 0.8]);
                shadedErrorBar(this.time,(this.greenRed.norm),this.greenRed.norm_sem,{'-r'},1);
                hold off
            end

        end
        
        function smooth(this,smoothing)
            
            if ~isfield(this.green,'norm')   %haven't yet run normalize
                warning('Have not yet run normalize method, running with default parameters now');
                this.normalize;
            end
            
            %default dgr is 1) whether it's on, then 2) whether it's possible 
            try
                dgr = this.analysisParams.dgr;
            catch
                this.analysisParams.dgr = isfield(this.red,'sum');
                dgr = this.analysisParams.dgr;
            end
            
            if nargin<2 %default smooth is 1) analysisParams, then 2) 4 samples
                try
                    smoothing = this.analysisParams.smoothing;
                catch
                    smoothing = 4; 
                end
            else %given new smoothing value, so update
                this.analysisParams.smoothing = smoothing;
            end
                
            
            
            this.green.smooth_norm = filtfilt(fspecial('gaussian',...
                [4,1],smoothing),1,this.green.norm);
            this.green.smooth_norm_sem = filtfilt(fspecial('gaussian',...
                [4,1],smoothing),1,this.green.norm_sem);

            if dgr
                this.greenRed.smooth_norm = filtfilt(fspecial('gaussian',...
                    [4,1],smoothing),1,this.greenRed.norm);
                this.greenRed.smooth_norm_sem = filtfilt(fspecial('gaussian',...
                    [4,1],smoothing),1,this.greenRed.norm_sem);
            end
            
        end
        
        function findPeaks(this,text_on)
            
            if nargin<2
                text_on = 0;
            end
            
            if ~isfield(this.green,'norm')   %haven't yet run normalize
                warning('Warning: Have not yet run normalize method, running with default parameters now');
                this.normalize;
            end
            
            if this.analysisParams.isSingle
                this.singlePeak(text_on);
            end
            
            this.triplePeak(text_on);
            
        end
        
        %VISUALIZATION SECTION
        function [varargout] = showImage(this, norm_range)
            
            if nargin<2;
                try
                    norm_range = this.analysisParams.norm_range;
                catch
                    norm_range = [0.05, 0.095]; %default time range for normalization in seconds
                    this.analysisParams.norm_range;
                end
            end
            
            load('/Users/ken/Documents/MATLAB/Lab/D1_Project/D1_Imaging/greenRedColorMap.mat');

            dt = this.rigParams.scanlinePeriod;
            norm_range = floor(norm_range./dt);

            this.green.normImage = this.green.image./mean(mean(this.green.image(norm_range(1):norm_range(2),:)));
            maxGreen = 1.05*max(max(this.green.normImage));

            try
                this.red.normImage = this.red.image./mean(mean(this.red.image(norm_range(1):norm_range(2),:)));
                maxRed = 1.05*max(max(this.red.normImage));
            catch %probably no red
                scrsz = get(groot,'ScreenSize');
                varargout{1} = figure('Position',[1 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2.55]);
                imagesc(0:dt:(size(this.green.image,1)-1)*dt,0:size(this.green.image,2),this.green.normImage');
                hold on
                ax_pre = gca;
                c = colorbar;
                c.Label.String = 'F(t)/F';
                colormap(ax_pre,greenMap);
                caxis([0 maxGreen]);
                ylabel('Pixel, Green');
                xlabel('Time, Seconds');
                hold off
                return
            end

            scrsz = get(groot,'ScreenSize');
            varargout{1} = figure('Position',[1 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2.55]);
            subplot(2,1,1)
            imagesc(0:dt:(size(this.green.image,1)-1)*dt,0:size(this.green.image,2),this.green.normImage');
            hold on
            ax_pre = gca;
            c = colorbar;
            c.Label.String = 'F(t)/F';
            colormap(ax_pre,greenMap);
            caxis([0 maxGreen]);
            ylabel('Pixel, Green');
            
            subplot(2,1,2)
            imagesc(0:dt:(size(this.red.image,1)-1)*dt,0:size(this.red.image,2),this.red.normImage');
            ax_post = gca;
            c = colorbar;
            c.Label.String = 'dR/R';
            colormap(ax_post,redMap);
            caxis([0 maxRed]);
            ylabel('Pixel, Red');
            
            xlabel('Time, Seconds');
            hold off


        end
        
        function [varargout] = plot_raw(this)
            
            scrsz = get(groot,'ScreenSize');
            varargout{1} = figure('Position',[scrsz(3)/2 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2.55]);
            
            hold on
            
            if isfield(this.red,'sum')
                plot(this.time,this.red.sum','Color',[1 0.8 0.8])
                shadedErrorBar(this.time,mean(this.red.sum),this.red.sem,{'Color',[0.4 0 0]},1)
            end
            
            plot(this.time,this.green.sum','Color',[0.8 1 0.8])
            shadedErrorBar(this.time,mean(this.green.sum),this.green.sem,{'Color',[0 0.4 0]},1)
            
            if isfield(this.red,'sum')
                y_max = max(max(max(this.green.sum)),max(max(this.red.sum)));
                y_min = min(min(min(this.green.sum)),min(min(this.red.sum)));
            else
                y_max = max(max(this.green.sum));
                y_min = min(min(this.green.sum));
            end
            
            x_max = max(this.time);
            
            ylabel('F(t)')
            xlabel('Time, seconds')
            axis([0,x_max,0,0.8*(y_max-y_min)+y_min])
            title('Raw Fluorescence')
            
            for i=1:length(this.stimTimes)
                plot([this.stimTimes(i),this.stimTimes(i)],[y_min, 1.1*y_max],'-k');
            end

            hold off

        end
                
        function [varargout] = plot_dFF(this,category)
            if nargin<2
                category = 2; %0=normalized, 1 = unnorm, 2 = smoothed norm
            end
            
            varargout{1} = this.plot(0,category);
        end
        
        function [varargout] = plot_dGR(this,category)
            if nargin<2
                category = 2; %0=normalized, 1 = unnorm, 2 = smoothed norm
            end
            
            varargout{1} = this.plot(1,category);
        end
                
        %ROUTINES
        function analyze(this)
            
            fprintf(['    -- ',this.name])
            cprintf('*green',' Normalize')
            this.normalize;
            cprintf('*red',' Smooth')
            this.smooth;
            cprintf('*blue',' findPeaks')
            this.findPeaks;
            cprintf('*black',' Saving')
            this.save;
            fprintf('\n')
            
        end
        
        function visualize(this,category,saveMe)
            
            if nargin<3
                saveMe = 0;
                if nargin<2
                    category = 2;
                end
            end
            
            %get raw image and plots
            rawImage = this.showImage;
            rawPlots = this.plot_raw;
            
            %get dF/F plot
            plot_dFF = this.plot_dFF(category);
            
            if saveMe
                savefig(rawImage,[this.location,'/rawImage']);
                savefig(rawPlots,[this.location,'/rawFluorescence']);
                savefig(plot_dFF,[this.location,'/dFF_plot']);
            end
            
            if this.analysisParams.dgr
                plot_dGR = this.plot_dGR(category);
                if saveMe
                    savefig(plot_dGR,[this.location,'/dGR_plot']);
                end
            end
            
        end
        
        function explore(this)
            
            this.analyze;
            this.visualize;
            
            this.save;
        end
        
        %UPDATE
        function updateAnalysisSettings(this)
            
            fprintf('\n');
            display('What do you want to modify?');
            fprintf('\n');
            params = fieldnames(this.analysisParams);
            for i=1:length(params)
                display(['    ',params{i},repmat(' ',1,20-length(params{i})),...
                    ':      ',num2str(this.analysisParams.(params{i}))])
            end
            fprintf('\n');
            target = input('  --> ','s');
            
            if any([strcmpi(target,'no'),strcmpi(target,'n')...
                    strcmpi(target,'quit'),strcmpi(target,'q')])
                display('quitting without saving');
                return
            end
            
            switch target
                case 'isSingle'
                    prompt = {'Turn on single analysis? (1 for yes, 0 for no)'};
                    defaultans = {num2str(this.analysisParams.isSingle)};
                case 'smoothing'
                    prompt = {'Enter smoothing STD (in samples)'};
                    defaultans = {num2str(this.analysisParams.smoothing)};
                case 'dgr'
                    prompt = {'Turn on delta G/R analysis? (1 for yes, 0 for no)'};
                    defaultans = {num2str(this.analysisParams.dgr)};
                case 'norm_range'
                    prompt = {'Enter start of normalization range (in seconds)',...
                        'Enter end of normalization range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.norm_range(1)),...
                        num2str(this.analysisParams.norm_range(2))};
                case 'single_sub'
                    prompt = {'Enter start of single stimulus subtraction range (in seconds)',...
                        'Enter end of single stimulus subtraction range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.single_sub(1)),...
                        num2str(this.analysisParams.single_sub(2))};
                case 'triple_sub'
                    prompt = {'Enter start of triple stimulus subtraction range (in seconds)',...
                        'Enter end of triple stimulus subtraction range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.triple_sub(1)),...
                        num2str(this.analysisParams.triple_sub(2))};
                case 'single_peak'
                    prompt = {'Enter start of single stimulus peak range (in seconds)',...
                        'Enter end of single stimulus peak range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.single_peak(1)),...
                        num2str(this.analysisParams.single_peak(2))};
                case 'triple_peak'
                    prompt = {'Enter start of triple stimulus peak range (in seconds)',...
                        'Enter end of triple stimulus peak range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.triple_peak(1)),...
                        num2str(this.analysisParams.triple_peak(2))};
                otherwise
                    warning('That is not a thing!')
                    return
            end
                    
            dlg_title = ['Update Analysis Settings - ',target];
            num_lines = length(prompt);
            answer = inputdlg(prompt,dlg_title,num_lines,defaultans);
            
            tempParams = struct();
            
            switch target
                case 'isSingle'
                    tempParams.isSingle = str2double(answer{1});
                case 'smoothing'
                    tempParams.smoothing = str2double(answer{1});
                case 'dgr'
                    tempParams.dgr = str2double(answer{1});
                case 'norm_range'
                    tempParams.norm_range = [str2double(answer{1}),str2double(answer{2})];
                case 'single_sub'
                    tempParams.single_sub = [str2double(answer{1}),str2double(answer{2})];
                case 'triple_sub'
                    tempParams.triple_sub = [str2double(answer{1}),str2double(answer{2})];
                case 'single_peak'
                    tempParams.single_peak = [str2double(answer{1}),str2double(answer{2})];
                case 'triple_peak'
                    tempParams.triple_peak = [str2double(answer{1}),str2double(answer{2})];
            end
            
            fprintf('\n');
            display('New Set of Parameters:');
            fprintf('\n');
            params = fieldnames(this.analysisParams);
            for i=1:length(params)
                if strcmpi(params{i},target)
                    if (this.analysisParams.(params{i}) == tempParams.(params{i}))
                        cprintf('*black',['    ',params{i},repmat(' ',1,20-length(params{i})),...
                        ':      ',num2str(tempParams.(params{i})),'\n'])
                    else
                        cprintf('*red',['    ',params{i},repmat(' ',1,20-length(params{i})),...
                        ':      ',num2str(tempParams.(params{i})),'\n'])
                    end
                else
                display(['    ',params{i},repmat(' ',1,20-length(params{i})),...
                    ':      ',num2str(this.analysisParams.(params{i}))])
                end
            end
            
            fprintf('\n');
            display('  Are you sure you want to continue? Y/N');
            abandon = input('  --> ','s');
            
            if any([strcmpi(abandon,'no'),strcmpi(abandon,'n')...
                    strcmpi(abandon,'quit'),strcmpi(abandon,'q')])
                display('quitting without saving');
                return
            elseif any([strcmpi(abandon,'yes'),strcmpi(abandon,'y')])
                fprintf('\n');
                display('Saving new parameters...');
                this.analysisParams.(target) = tempParams.(target);
                display('Rerunning "explore" with new parameters...');

                this.explore
            end
            
        end
        
        function reset(this,listening,fullReset)
            
            if nargin<3
                fullReset = 0;
                if nargin<2
                    listening = 0;
                end
            end
            
            if ~listening
                while (1)
                    fprintf('\n');
                    cprintf('*red',['Are you SURE you want to RESET ',this.name,'?']);

                    fprintf('\n');
                    target = input('  --> ','s');

                    if any([strcmpi(target,'no'),strcmpi(target,'n')...
                            strcmpi(target,'quit'),strcmpi(target,'q')])
                        display('quitting without saving');
                        return
                    elseif any([strcmpi(target,'yes'),strcmpi(target,'y')...
                            strcmpi(target,'continue'),strcmpi(target,'cont')])
                        break
                    else
                        display('Must answer with "Yes or No"');
                        continue
                    end
                end

                while (1)
                    fprintf('\n');
                    cprintf('*red','Reset XML data as well (this will add a lot of time)?');

                    fprintf('\n');
                    target = input('  --> ','s');

                    if any([strcmpi(target,'no'),strcmpi(target,'n')...
                            strcmpi(target,'quit'),strcmpi(target,'q')])
                        break
                    elseif any([strcmpi(target,'yes'),strcmpi(target,'y')...
                            strcmpi(target,'continue'),strcmpi(target,'cont')])
                        display('resetting');

                        this.xmlData = [];
                        this.rigParams = [];
                        this.time = [];

                        this.importXmlData;
                        this.importRigParams;

                        disp(['     ' this.name ' --- XML Data RESET']);
                        break

                    else
                        display('Must answer with "Yes or No"');
                        continue
                    end
                end
            end
            
            if fullReset
                this.xmlData = [];
                this.rigParams = [];
                this.time = [];

                this.importXmlData;
                this.importRigParams;

                disp(['     ' this.name ' --- XML Data RESET']);
            end
            
            this.red = [];
            this.green = [];
            this.greenRed = [];
            this.peaks = [];
            
            this.redRaw = [];
            this.greenRaw = [];
            this.analysisParams = [];    %stuff you will need to reproduce analyses
            this.maskedPixels = [];      %masked pixels (rows) in each frame (columns)
            
            this.importImagingData;
            this.initializeDefaultAnalysis;
            
            delete([this.location '/*.mat'])
            delete([this.location '/*.fig'])

            disp(['     ' this.name ' --- Imaging Data RESET']);
            fprintf('\n')
        end
        
        function save(this)
            lineScan = this; %#ok<NASGU>
            save([this.location,'/',this.name,'.mat'],'lineScan');
        end
        
        function listenHandles = restoreListeners(this,containerObj)
            
            listenHandles = cell(1,3);
            
            display(['      Restoring Listeners of ',this.name,' to Bouton ',containerObj.name])
            
            if isobject(containerObj)       %true when bouton is being put into 
                                            %array of another object like experiment, so we can listen
                listenHandles{1} = addlistener(containerObj,'Reset',@this.eventReset);
                listenHandles{2} = addlistener(containerObj,'SaveFigs',@this.eventSaveFigs);
                listenHandles{3} = addlistener(containerObj,'ChangeParams',@this.eventChangeParams);
            end
                        
        end
        
    end
    
    methods (Access = private)
        
        %Importing Functions
        function importNameAndLoc(this,path)
            [~, this.name] = fileparts(path);
            this.location = path;
        end

        function importXmlData(this)
            %Imports the xml file into an xml thisect that is easy to parse
            %with matlab. Requires xml2struct
            try
                xmlFile = dir([this.location,'/LineScan*.xml']);
                this.xmlData = xml2struct([this.location,'/',xmlFile(1).name]);
                this.rigParams.date = this.xmlData.PVScan.Attributes.date;
            catch
                error(['No xml file found for ' this.name]);
            end
        end
        
        function importRigParams(this)
            try
                if strcmp(this.xmlData.PVScan.SystemConfiguration.Lasers.Laser.Attributes.name,'Imaging')...
                        && strcmp(this.xmlData.PVScan.Sequence{1, 1}.Attributes.type,'Linescan')
                    %Bluefish xml settings
                    this.rigParams.rig = 'bluefish';
                    this.rigParams.greenPMTGain = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 23}.Attributes.value);
                    this.rigParams.redPMTGain = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 25}.Attributes.value);
                    this.rigParams.laserPower = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 28}.Attributes.value);
                    this.rigParams.numFrames = length(this.xmlData.PVScan.Sequence);
                    this.rigParams.pixelsPerLine = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 6}.Attributes.value);
                    this.rigParams.linesPerFrame = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 7}.Attributes.value);
                    this.rigParams.scanlinePeriod = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 12}.Attributes.value);
                    this.rigParams.micronPerPixelX = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 21}.Attributes.value);
                end
            catch
                if strcmp(this.xmlData.PVScan.SystemConfiguration.Lasers.Laser{1, 1}.Attributes.name,'Imaging Laser')...
                        && strcmp(this.xmlData.PVScan.Sequence{1, 1}.Attributes.type,'Linescan')
                    %Thing1 xml settings
                    this.rigParams.rig = 'Thing1';
                    this.rigParams.greenPMTGainTop = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 28}.Attributes.value);
                    this.rigParams.greenPMTGainBottom = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 27}.Attributes.value);
                    this.rigParams.redPMTGainTop = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 23}.Attributes.value); 
                    this.rigParams.redPMTGainBottom = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 24}.Attributes.value);
                    this.rigParams.laserPower = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 30}.Attributes.value);
                    this.rigParams.numFrames = length(this.xmlData.PVScan.Sequence);
                    this.maskedPixels = zeros(1,this.rigParams.numFrames);
                    this.rigParams.pixelsPerLine = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 6}.Attributes.value);
                    this.rigParams.linesPerFrame = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 7}.Attributes.value);
                    this.rigParams.scanlinePeriod = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 12}.Attributes.value);
                    this.rigParams.micronPerPixelX = str2double(this.xmlData.PVScan.Sequence{1, 1}.Frame.PVStateShard.Key{1, 21}.Attributes.value);    
                else
                    error(['Problem importing imaging parameters for ' this.name]);
                end
                                
            this.time = 0:this.rigParams.scanlinePeriod:this.rigParams.scanlinePeriod*(this.rigParams.linesPerFrame-1);
                        
            end
        end
        
        function importImagingData(this)
            
            %Import imaging data
            alexaFiles = dir([this.location,'/Alexa/LineScan*.tif']);
            fluoFiles = dir([this.location,'/Fluo/LineScan*.tif']);
            
            this.rigParams.numFrames = size(fluoFiles,1); %this is actually correct
            this.numTrials = this.rigParams.numFrames; %for easier access to number of trials
            
            for i=1:length(alexaFiles)
                this.redRaw(i,:,:) = double(imread([this.location,'/Alexa/',alexaFiles(i).name]));
            end
            for i=1:length(fluoFiles)
                this.greenRaw(i,:,:) = double(imread([this.location,'/Fluo/',fluoFiles(i).name]));
            end
            this.rigParams.numPixels = size(this.greenRaw,3);
            this.maskedPixels = zeros(this.rigParams.numPixels,this.rigParams.numFrames);

            % Filter out background
            try
                for i=1:length(this.redRaw(:,1,1)) % go through each scan
                    mask = zeros(1,length(this.redRaw(i,1,:))); %number of pixels
                    for j=1:length(this.redRaw(i,1,:)) %go through each pixel
                        mask(j) = sum(this.redRaw(i,:,j)); %sum all timepoints for that pixel and scan
                    end
                    threshold = max(mask).*0.1; 
                    
                    %Convert mask to binary
                    for j=1:length(mask)
                        if mask(j) > threshold %#ok<BDSCI>
                            mask(j) = 1;
                        else
                            mask(j) = 0;
                            warning(['Masking enforced for frame ',num2str(i)]);
                            this.maskedPixels(j,i) = 1;
                        end
                    end

                    %Multiply scans by mask
                    for j=1:length(this.redRaw(i,1,:))
                        this.redRaw(i,:,j) = this.redRaw(i,:,j).*mask(j);
                        this.greenRaw(i,:,j) = this.greenRaw(i,:,j).*mask(j);
                    end 
                end
            catch % Likely there is no red (ie GCAMP imaging)
                for i=1:length(this.greenRaw(:,1,1))
                    %go through each frame
                    for j=1:length(this.greenRaw(i,1,:))
                        mask(j) = sum(this.greenRaw(i,:,j));
                        threshold = max(mask).*0.1;
                    end

                    %Convert mask to binary
                    for j=1:length(mask)
                        if mask(j) > threshold
                            mask(j) = 1;
                        else
                            mask(j) = 0;
                            warning(['Masking enforced for frame ',num2str(i)]);
                            this.maskedPixels(j,i) = 1;
                        end
                    end

                    %Multiply scans by mask
                    for j=1:length(this.greenRaw(i,1,:))
                        this.greenRaw(i,:,j) = this.greenRaw(i,:,j).*mask(j);
                    end 
                end
            end
            
            % now get "sum" across pixels
            
            % normalize sum to number of unmasked pixels in each frame
            unmasked = this.rigParams.numPixels - sum(this.maskedPixels,1);
            this.green.sum = bsxfun(@rdivide, sum(this.greenRaw,3)',unmasked)';
            this.green.sem = std(this.green.sum,1)./sqrt(length(this.green.sum(:,1)));

            try
            this.red.sum = bsxfun(@rdivide, sum(this.redRaw,3)',unmasked)';
            this.red.sem = std(this.red.sum,1)./sqrt(length(this.red.sum(:,1)));

            catch % Likely there is no red (ie GCAMP imaging)
                %whatever
            end
            
            % Average the linescans for pictures
            try
                this.red.image = squeeze(mean(this.redRaw));
                this.green.image = squeeze(mean(this.greenRaw));
            catch
                this.green.image = squeeze(mean(this.greenRaw));
            end


        end
        
        function importTimeData(this)
            
            for i=1:this.numTrials
                this.globalScanTimes{i} =...
                    this.xmlData.PVScan.Sequence{i}.Attributes.time;
            end
            
            this.globalScanTimes = datenum(this.globalScanTimes,'HH:MM:SS');
            
            this.relScanTimes = (1e5/60).*(this.globalScanTimes - this.globalScanTimes(1)); %in minutes
            
        end
        
        function initializeDefaultAnalysis(this)
            
            this.stimTimes = [0.05,0.1];
            this.analysisParams.isSingle = 0;
            this.analysisParams.smoothing = 4;
            this.analysisParams.dgr = isfield(this.red,'sum');
            this.analysisParams.norm_range = [0.075,0.09];
            this.analysisParams.triple_peak = [0.104,0.111];   
            this.analysisParams.triple_sub = [0.085,0.09];
            this.analysisParams.single_peak = [0.13,0.16];
            this.analysisParams.single_sub = [0.085,0.09];
            
        end
        
        %Value Calculations
        function [peak_results_dff, varargout] =...
                peakFCalc(this,bline_range,peak_range,dgr,text_on)
            
            peak_results_dff = struct();

            % convert from time to points
            
            dt = this.rigParams.scanlinePeriod;

            bline_range = floor(bline_range./dt);
            peak_range = floor(peak_range./dt);
            
            peak_results_dff.allPeaks_raw = zeros(1,this.numTrials);
            peak_results_dff.allBase_raw = zeros(1,this.numTrials);
            peak_results_dff.allPeaks_norm = zeros(1,this.numTrials);
            
            % get raw peak F and raw baseline F vectors
            
            for i=1:this.numTrials;
                peak_results_dff.allPeaks_raw(i) = mean(this.green.sum(i,peak_range(1):peak_range(2)));
                peak_results_dff.allBase_raw(i) = mean(this.green.sum(i,bline_range(1):bline_range(2)));
            end
            
            % calculate dF/F peaks

            peak_results_dff.allPeaks_norm = (peak_results_dff.allPeaks_raw...
                -peak_results_dff.allBase_raw)./mean(peak_results_dff.allBase_raw);
            
            % calculate G/R (conditional)
            
            if dgr
                
                peak_results_dgr.allPeaks_raw = zeros(1,this.numTrials);
                peak_results_dgr.allBase_raw = zeros(1,this.numTrials);
                peak_results_dgr.allPeaks_norm = zeros(1,this.numTrials);
            
                % get raw peak G/R and raw baseline G/R vectors

                for i=1:this.numTrials;
                    peak_results_dgr.allPeaks_raw(i) = mean(this.greenRed.sum(i,peak_range(1):peak_range(2)));
                    peak_results_dgr.allBase_raw(i) = mean(this.greenRed.sum(i,bline_range(1):bline_range(2)));
                end

                % calculate dG/R peaks

                peak_results_dgr.allPeaks_norm = (peak_results_dgr.allPeaks_raw...
                    -peak_results_dgr.allBase_raw)./mean(peak_results_dgr.allBase_raw);

                
                varargout{1} = peak_results_dgr;
            end
            
        end
        
        function singlePeak(this,text_on)
            
            if text_on
                fprintf('\n')
                display(['--Single'])
            end
            if this.analysisParams.dgr;
                [peak_dff.single,peak_dgr.single] = peakFCalc(this,...
                    this.analysisParams.single_sub,this.analysisParams.single_peak,...
                    this.analysisParams.dgr, text_on);
            else
                [peak_dff.single] = peakFCalc(this,...
                    this.analysisParams.single_sub,this.analysisParams.single_peak,...
                    this.analysisParams.dgr, text_on);
            end
            
            if text_on
                fprintf('\n'); 
            end
            
            this.peaks.dff_single = peak_dff.single;
            if this.analysisParams.dgr;
                this.peaks.dgr_single = peak_dgr.single;
            end
            
        end
        
        function triplePeak(this,text_on)
            
            if text_on
                fprintf('\n')
                display(['--Triple'])
            end
            if this.analysisParams.dgr;
                [peak_dff.triple,peak_dgr.triple] = peakFCalc(this,...
                    this.analysisParams.triple_sub,...
                    this.analysisParams.triple_peak,...
                    this.analysisParams.dgr,text_on);
            else
                [peak_dff.triple] = peakFCalc(this,...
                    this.analysisParams.triple_sub,...
                    this.analysisParams.triple_peak,...
                    this.analysisParams.dgr,text_on);
            end
            
            if text_on
                fprintf('\n'); 
            end
            
            this.peaks.dff = peak_dff.triple;
            if this.analysisParams.dgr;
                this.peaks.dgr = peak_dgr.triple;
            end
            
        end   
        
        %Plotting Functions
        function [varargout] = plot(this,dgr_on,category)
            
            if nargin<3
                category = 2; %0=normalized, 1 = unnorm, 2 = smoothed norm
                if nargin <2
                    dgr_on = 0; %default to dF/F
                end
            end
            
            if ~(category==1)
                if ~isfield(this.green,'smooth_norm')
                    warning('Have not yet run smooth method, running with default parameters now');
                    this.smooth;
                end
            end
            
            scrsz = get(groot,'ScreenSize');
            if dgr_on
                varargout{1} = figure('Position',[scrsz(3)/2 0 scrsz(3)/2 scrsz(4)/2.55]);
            else
                varargout{1} = figure('Position',[1 0 scrsz(3)/2 scrsz(4)/2.55]);
            end
            hold on
                        
            if dgr_on  %dG/R
                if category == 1 %unnorm
                    plot(this.time,this.greenRed.sum','Color',[0.85 0.85 0.6]);
                    hold on
                    h_this = shadedErrorBar(this.time,mean(this.greenRed.sum),this.greenRed.sem,'k-',1);
                    y_max = max(max(this.greenRed.sum));
                    y_min = min(min(this.greenRed.sum));
                elseif category == 2 %smoothed
                    plot(this.time,this.greenRed.normMat','Color',[0.85 0.85 0.6]);
                    hold on
                    h_this = shadedErrorBar(this.time,this.greenRed.smooth_norm,this.greenRed.smooth_norm_sem,'k-',1);
                    y_max = max(this.greenRed.smooth_norm);
                    y_min = min(this.greenRed.smooth_norm);
                else %just normalized
                    plot(this.time,this.greenRed.normMat','Color',[0.85 0.85 0.6]);
                    hold on
                    h_this = shadedErrorBar(this.time,this.greenRed.norm,this.greenRed.norm_sem,'k-',1);
                    y_max = max(this.greenRed.norm);
                    y_min = min(this.greenRed.norm);
                end

            else    %dF/F
                if category == 1 %unnorm
                    plot(this.time,this.green.sum','Color',[0.6 0.85 0.6]);
                    hold on
                    h_this = shadedErrorBar(this.time,mean(this.green.sum),this.green.sem,'k-',1);
                    y_max = max(max(this.green.sum));
                    y_min = min(min(this.green.sum));
                elseif category == 2 %smoothed
                    plot(this.time,this.green.normMat','Color',[0.6 0.85 0.6]);
                    hold on
                    h_this = shadedErrorBar(this.time,this.green.smooth_norm,this.green.smooth_norm_sem,'k-',1);
                    y_max = max(this.green.smooth_norm);
                    y_min = min(this.green.smooth_norm);
                else %just normalized
                    plot(this.time,this.green.normMat','Color',[0.6 0.85 0.6]);
                    hold on
                    h_this = shadedErrorBar(this.time,this.green.norm,this.green.norm_sem,'k-',1);
                    y_max = max(this.green.norm);
                    y_min = min(this.green.norm);
                end
            end

            x_max = max(this.time);
            
            for i=1:length(this.stimTimes)
                plot([this.stimTimes(i),this.stimTimes(i)],[y_min, 1.1*y_max],'-k');
            end
            
            if category == 1 %%unnorm
                axis([0,1.01*x_max,0.85*y_min,(1.1*(y_max-y_min)+y_min)])
                title('Raw Fluorescence, Pre vs Post')
                if dgr_on
                    ylabel('G/R(t)')
                else
                    ylabel('F(t)')
                end
            else %% norm
                axis([0,1.01*x_max,y_min-0.2,1.4*y_max])
                if dgr_on
                    title('dG/R, Pre vs Post')
                    ylabel('dG/R')
                else
                    title('dF/F, Pre vs Post')
                    ylabel('dF/F')
                end
                plot([0,1.01*x_max],[0,0],'--k')
            end
            xlabel('Time, seconds')
            
            hold off
        end
        
        %Listener Callbacks
        function eventReset(this,eventCaller,eventData)
                        
            listening = 1;
            
            fullReset = eventData.bcState;
            
            this.reset(listening,fullReset);
            
        end
        
        function eventSaveFigs(this,eventCaller,eventData)
            
            saveMe = eventData.bcState;
            category = 2;
            
            fprintf('\n')
            cprintf('*black',['    ---', this.name]);
            
            this.visualize(category,saveMe);
            close all
            
        end
        
        function eventChangeParams(this,eventCaller,eventData)

            saveParam = eventData.bcState;
            dataParam = eventData.bcData;
            nameParam = eventData.bcType;
            
                        
            if all([isfield(this.analysisParams,nameParam), saveParam])

                this.analysisParams.(nameParam) = dataParam;
                
                fprintf('\n')
                cprintf('*red',['  --- SAVING NEW PARAM ', nameParam, ' as   -->       ', num2str(dataParam)]);
                fprintf('\n')
                cprintf('*red',['            in Scan ', this.name]);
                fprintf('\n\n')
            
            end
            
        
        end
        
    end
    
end