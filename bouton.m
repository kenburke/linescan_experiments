classdef bouton < handle
    
    properties
        name = [];
        location = [];
        scans = [];
        peak_dFF = [];
        peak_dGR = [];
        stimTimes = [];
    end
    
    properties (SetAccess = private, Hidden = true)
        relSetTimes = [];
        relScanTimes = []; %cell array of scan times for each scan set, 
                           %relative to first scan in first set
        relScanTimes_cell = [];
        analysisParams = [];
        plottingParams = [];
    end
    
    properties (Transient)
        scanListeners = [];
    end
    
    events
        Reset
        SaveFigs
        ChangeParams
    end
    
    methods
        
        %starting off
        function obj = bouton(fullPath, containerObj)
            % make a bouton from folder containing Linescan folders
            % generated by Prairie
            
            if nargin < 2
                containerObj = 'off';
                if nargin<1
                    fullPath = pwd; %you're in the folder
                end
            end
            
            
            obj.importNameAndLoc(fullPath);
            fprintf('\n')
            fprintf('\n')
            cprintf('*black',['  ',obj.name ' Importing...']);
            fprintf('\n')
            obj.initializeDefaultAnalysis;
            obj.importLineScans;
            obj.importTimeData;
            
            dgr=1;
            for i=1:obj.analysisParams.numScanSets;
                dgr = dgr*isfield(obj.scans{i}.red,'sum');
            end
            
            obj.analysisParams.dgr = dgr;  % this should be OFF unless ALL 
                                 % linescans have dGR (individual linescans
                                 % have dgr capabilities, but you should 
                                 % write custom scripts if you want to do
                                 % dGR analysis with partial datasets)
            
            if isobject(containerObj)       %true when bouton is being put into 
                                            %array of another object like experiment, so we can listen
                addlistener(containerObj,'Reset',@obj.eventReset);
                addlistener(containerObj,'SaveFigs',@obj.eventSaveFigs);
                addlistener(containerObj,'UpdateAnalysis',@obj.eventUpdateAnalysis);
            end
                                 
            cprintf('*black',['  ',obj.name ' Imported']);
            
        end
        
        %ANALYSIS SECTION (bouton-specific methods)
        function pullPeaks(this)
            
            this.peak_dFF = [];
            this.peak_dGR = [];
            
            dgr = this.analysisParams.dgr;  % means ALL linescans have Red for dgr analysis
            
            this.peak_dFF.raw_set_peak = zeros(1,this.analysisParams.numScanSets);
            this.peak_dFF.raw_set_base = zeros(1,this.analysisParams.numScanSets);
            this.peak_dFF.norm_set_peak = zeros(1,this.analysisParams.numScanSets);
            
            this.peak_dFF.raw_scan_peak = cell(1,this.analysisParams.numScanSets);
            this.peak_dFF.raw_scan_base = cell(1,this.analysisParams.numScanSets);
            this.peak_dFF.norm_scan_peak = cell(1,this.analysisParams.numScanSets);
            
            if dgr
                this.peak_dGR.raw_set_peak = zeros(1,this.analysisParams.numScanSets);
                this.peak_dGR.raw_set_base = zeros(1,this.analysisParams.numScanSets);
                this.peak_dGR.norm_set_peak = zeros(1,this.analysisParams.numScanSets);
                
                this.peak_dGR.raw_scan_peak = cell(1,this.analysisParams.numScanSets);
                this.peak_dGR.raw_scan_base = cell(1,this.analysisParams.numScanSets);
                this.peak_dGR.norm_scan_peak = cell(1,this.analysisParams.numScanSets);
            end
                      
            for i=1:this.analysisParams.numScanSets;
                
                this.peak_dFF.raw_scan_peak{i} = this.scans{i}.peaks.dff.allPeaks_raw;
                this.peak_dFF.raw_scan_base{i} = this.scans{i}.peaks.dff.allBase_raw;
                this.peak_dFF.norm_scan_peak{i} = this.scans{i}.peaks.dff.allPeaks_norm;
                
                if dgr
                    this.peak_dGR.raw_scan_peak{i} = this.scans{i}.peaks.dgr.allPeaks_raw;
                    this.peak_dGR.raw_scan_base{i} = this.scans{i}.peaks.dgr.allBase_raw;
                    this.peak_dGR.norm_scan_peak{i} = this.scans{i}.peaks.dgr.allPeaks_norm;
                end
                
                this.peak_dFF.raw_set_peak(i) = mean(this.peak_dFF.raw_scan_peak{i});
                this.peak_dFF.raw_set_base(i) = mean(this.peak_dFF.raw_scan_base{i});
                this.peak_dFF.norm_set_peak(i) = mean(this.peak_dFF.norm_scan_peak{i});
                
                if dgr    
                    this.peak_dGR.raw_set_peak(i) = mean(this.peak_dGR.raw_scan_peak{i});
                    this.peak_dGR.raw_set_base(i) = mean(this.peak_dGR.raw_scan_base{i});
                    this.peak_dGR.norm_set_peak(i) = mean(this.peak_dGR.norm_scan_peak{i});
                end
                
            end
            
            %make them all matricies
            
            this.peak_dFF.raw_scan_peak = cell2mat(this.peak_dFF.raw_scan_peak);
            this.peak_dFF.raw_scan_peak = reshape(this.peak_dFF.raw_scan_peak,1,...
                size(this.peak_dFF.raw_scan_peak,1)*size(this.peak_dFF.raw_scan_peak,2));
            
            this.peak_dFF.raw_scan_base = cell2mat(this.peak_dFF.raw_scan_base);
            this.peak_dFF.raw_scan_base = reshape(this.peak_dFF.raw_scan_base,1,...
                size(this.peak_dFF.raw_scan_base,1)*size(this.peak_dFF.raw_scan_base,2));
            
            this.peak_dFF.norm_scan_peak = cell2mat(this.peak_dFF.norm_scan_peak);
            this.peak_dFF.norm_scan_peak = reshape(this.peak_dFF.norm_scan_peak,1,...
                size(this.peak_dFF.norm_scan_peak,1)*size(this.peak_dFF.norm_scan_peak,2));
            
            if dgr
                this.peak_dGR.raw_scan_peak = cell2mat(this.peak_dGR.raw_scan_peak);
                this.peak_dGR.raw_scan_peak = reshape(this.peak_dGR.raw_scan_peak,1,...
                    size(this.peak_dGR.raw_scan_peak,1)*size(this.peak_dGR.raw_scan_peak,2));

                this.peak_dGR.raw_scan_base = cell2mat(this.peak_dGR.raw_scan_base);
                this.peak_dGR.raw_scan_base = reshape(this.peak_dGR.raw_scan_base,1,...
                    size(this.peak_dGR.raw_scan_base,1)*size(this.peak_dGR.raw_scan_base,2));

                this.peak_dGR.norm_scan_peak = cell2mat(this.peak_dGR.norm_scan_peak);
                this.peak_dGR.norm_scan_peak = reshape(this.peak_dGR.norm_scan_peak,1,...
                    size(this.peak_dGR.norm_scan_peak,1)*size(this.peak_dGR.norm_scan_peak,2));
            end
            
            %get first-scanset-normalized vectors
            this.peak_dFF.firstSetNorm_scan_peak = this.peak_dFF.norm_scan_peak...
                ./mean(this.peak_dFF.norm_set_peak(1:2));
            this.peak_dFF.firstSetNorm_set_peak = this.peak_dFF.norm_set_peak...
                ./mean(this.peak_dFF.norm_set_peak(1:2));
            
            if dgr
                this.peak_dGR.firstSetNorm_scan_peak = this.peak_dGR.norm_scan_peak...
                    ./mean(this.peak_dGR.norm_set_peak(1:2));
                this.peak_dGR.firstSetNorm_set_peak = this.peak_dGR.norm_set_peak...
                    ./mean(this.peak_dGR.norm_set_peak(1:2));
            end
            
            % do singles
            if this.analysisParams.isSingle
                this.peak_dFF.single.raw_set_peak = zeros(1,this.analysisParams.numScanSets);
                this.peak_dFF.single.raw_set_base = zeros(1,this.analysisParams.numScanSets);
                this.peak_dFF.single.norm_set_peak = zeros(1,this.analysisParams.numScanSets);

                if dgr
                    this.peak_dGR.single.raw_set_peak = zeros(1,this.analysisParams.numScanSets);
                    this.peak_dGR.single.raw_set_base = zeros(1,this.analysisParams.numScanSets);
                    this.peak_dGR.single.norm_set_peak = zeros(1,this.analysisParams.numScanSets);
                end

                for i=1:this.analysisParams.numScanSets;
                    if dgr    % means ALL linescans have Red for dgr analysis
                        this.peak_dGR.single.raw_set_peak(i) = mean(this.scans{i}.peaks.dgr_single.allPeaks_raw);
                        this.peak_dGR.single.raw_set_base(i) = mean(this.scans{i}.peaks.dgr_single.allBase_raw);
                        this.peak_dGR.single.norm_set_peak(i) = this.scans{i}.peaks.dgr_single.mean_dgr;
                    end
                    this.peak_dFF.single.raw_set_peak(i) = mean(this.scans{i}.peaks.dff_single.allPeaks_raw);
                    this.peak_dFF.single.raw_set_base(i) = mean(this.scans{i}.peaks.dff_single.allBase_raw);
                    this.peak_dFF.single.norm_set_peak(i) = this.scans{i}.peaks.dff_single.mean_dff;
                end
            end
            
        end
        
        %VISUALIZATION SECTION (bouton-specific methods)
        function [varargout] = plot_raw_data(this)
            %raw G and R comparisons
                        
            if isfield(this.scans{1}.red,'sum')
                
                scrsz = get(groot,'ScreenSize');
                varargout{1} = figure('Position',[1 scrsz(4)/2 scrsz(3) scrsz(4)/2.55]);
                hold on

                % plot everything on loop
                num_scans = this.analysisParams.numScanSets;
                y_max = zeros(1,num_scans);
                y_min = zeros(1,num_scans);
                for i=1:num_scans

                    subplot(1,num_scans,i);
                    hold on
                    plot(this.scans{i}.time,(this.scans{i}.red.sum'),'Color',[1 0.8 0.8])
                    shadedErrorBar(this.scans{i}.time,mean(this.scans{i}.red.sum),...
                        this.scans{i}.red.sem,{'Color',[0.4 0 0]},0)
                    %plot(this.scans{i}.time,mean(this.scans{i}.red.num),'Color',[0.4 0 0])
                    plot(this.scans{i}.time,(this.scans{i}.green.sum'),'Color',[0.8 1 0.8])
                    shadedErrorBar(this.scans{i}.time,mean(this.scans{i}.green.sum),...
                        this.scans{i}.green.sem,{'Color',[0 0.4 0]},0)

                    y_max(i) = max(max(max(this.scans{i}.green.sum)),max(max(this.scans{i}.red.sum)));
                    y_min(i) = min(min(min(this.scans{i}.green.sum)),min(min(this.scans{i}.red.sum)));
                end

                y_max = max(max(y_max));
                y_min = min(min(y_min));
                x_max = max(this.scans{1}.time);

                %format
                for i=1:num_scans

                    subplot(1,num_scans,i);
                    ylabel('F(t)');
                    xlabel('Time, seconds');
                    axis([0,x_max,0,0.9*(y_max-y_min)+y_min]);
                    title(['Scan ', num2str(i)]);
                end

                hold off
                
            else   %no red, just green
                
                scrsz = get(groot,'ScreenSize');
                varargout{1} = figure('Position',[1 scrsz(4)/2 scrsz(3) scrsz(4)/2.55]);
                hold on

                % plot everything on loop
                num_scans = this.analysisParams.numScanSets;
                y_max = zeros(1,num_scans);
                y_min = zeros(1,num_scans);
                for i=1:num_scans

                    subplot(1,num_scans,i);
                    hold on
                    plot(this.scans{i}.time,(this.scans{i}.green.sum'),'Color',[0.8 1 0.8])
                    shadedErrorBar(this.scans{i}.time,mean(this.scans{i}.green.sum),...
                        this.scans{i}.green.sem,{'Color',[0 0.4 0]},1)

                    y_max(i) = max(max(this.scans{i}.green.sum));
                    y_min(i) = min(min(this.scans{i}.green.sum));
                end

                y_max = max(max(y_max));
                y_min = min(min(y_min));
                x_max = max(this.scans{1}.time);

                %format
                for i=1:num_scans

                    subplot(1,num_scans,i);
                    ylabel('F(t)');
                    xlabel('Time, seconds');
                    axis([0,x_max,0,1.1*y_max]);
                    title(['Scan ', num2str(i)]);
                end

                hold off
            end
            
        end
        
        function [varargout] = plot_mean_dFF(this,category)
            if nargin<2
                category = 2; %0=normalized, 1 = unnorm, 2 = smoothed norm
            end
            
            dgr = 0;
            
            varargout{1} = this.plot_mean_scans(dgr,category);
        end
        
        function [varargout] = plot_mean_dGR(this,category)
            if nargin<2
                category = 2; %0=normalized, 1 = unnorm, 2 = smoothed norm
            end
            
            dgr = 1;
            
            varargout{1} = this.plot_mean_scans(dgr,category);
        end
        
        function [varargout] = plotPeakAmps_sets(this,dgr,single)
            
            %"sets" are sets of linescans (i.e. all linescans in a lineScan
            %object). So this will plot the amplitudes by set, as the mean
            %of each set. If you want to see all scans for this bouton
            %across sets, run "this.plotPeakAmps_all" instead
            
            %assume that you're just plotting the peak dF/F for triples
            if nargin<3
                single = 0;
                if nargin<2
                    dgr = 0;
                end
            end
            
            scrsz = get(groot,'ScreenSize');
            varargout{1} = figure('Position',[scrsz(3)/2 1 scrsz(3)/2 scrsz(4)/2.55]);
            
            % plot peak Single change (if turned on)
            if single
                hold on

                [s_ff]=plot(this.peak_dFF.single.norm_set_peak,'Color',[0 0 0.7],'Marker','o','MarkerSize',10);
                x_max = length(this.peak_dFF.single.norm_set_peak);

                if dgr
                    [s_gr]=plot(this.peak_dGR.single.norm_set_peak,'Color',[0.7 0 0],'Marker','o','MarkerSize',10);
                    legend([s_gr,s_ff],'dG/R','dF/F');
                    y_max = max(max(this.peak_dGR.single.norm_set_peak),...
                        max(this.peak_dFF.single.norm_set_peak));
                    y_min = min(min(min(this.peak_dGR.single.norm_set_peak),...
                        min(this.peak_dFF.single.norm_set_peak)),0);
                else
                    legend(s_ff,'dF/F');
                    y_max = max(this.peak_dFF.single.norm_set_peak);
                    y_min = min(min(this.peak_dFF.single.norm_set_peak),0);
                end
                plot([0,x_max+1],[this.peak_dFF.single.norm_set_peak(1),...
                    this.peak_dFF.single.norm_set_peak(1)],'k--');
                plot([0,x_max+1],[0,0],'k-');
                axis([0.5,x_max+0.5,y_min-0.1,y_max+0.1]);
                ylabel('Peak, Single');
                xlabel('Scan Set Number');
                title('Change in Peaks, Single');
                hold off
            else
            % plot peak Triple change
                hold on

                [t_ff]=plot(this.peak_dFF.norm_set_peak,'Color',[0 0 0.7],'Marker','o','MarkerSize',10);
                x_max = length(this.peak_dFF.norm_set_peak);

                if dgr
                    [t_gr]=plot(this.peak_dGR.norm_set_peak,'Color',[0.7 0 0],'Marker','o','MarkerSize',10);
                    legend([t_gr,t_ff],'dG/R','dF/F');
                    y_max = max(max(this.peak_dGR.norm_set_peak),...
                        max(this.peak_dFF.norm_set_peak));
                    y_min = min(min(min(this.peak_dGR.norm_set_peak),...
                        min(this.peak_dFF.norm_set_peak)),0);
                else
                    legend(t_ff,'dF/F');
                    y_max = max(this.peak_dFF.norm_set_peak);
                    y_min = min(min(this.peak_dFF.norm_set_peak),0);
                end
                plot([0,x_max+1],[this.peak_dFF.norm_set_peak(1),...
                    this.peak_dFF.norm_set_peak(1)],'k--');
                plot([0,x_max+1],[0,0],'k-');
                axis([0.5,x_max+0.5,y_min-0.1,y_max+0.1]);
                ylabel('Peak, Triple');
                xlabel('Scan Set Number');
                title('Change in Peaks, Triple');
                hold off
            end
        end
        
        function [varargout] = plotPeakAmps_all(this,dgr)
            
            %This plots the peak amplitudes of all scans contained in this
            %bouton, usually alongside the mean for each set of linescans,
            %both normalized to first scan set and "unnormalized" dF/F
            %If you just want the mean amplitude per linescan set, see
            %"this.plotPeakAmps_sets" above
            
            if nargin<1
                dgr = 0;
            end
            
            varargout{1} = figure();
            hold on
            x_max = max(this.relScanTimes);
            
            plot([0,x_max+1],[1,1],'k--');
            plot([0,x_max+1],[0,0],'k-');
            
            start = 1;           
            stop = 0;
            
            if dgr
                
                for i=1:this.analysisParams.numScanSets

                    stop = stop + length(this.relScanTimes_cell{i});
                    plot(this.relScanTimes_cell{i},...
                        this.peak_dGR.firstSetNorm_scan_peak(start:stop),...
                        'o');
                    start = start + length(this.relScanTimes_cell{i});

                end
                
            else
                
                for i=1:this.analysisParams.numScanSets

                    stop = stop + length(this.relScanTimes_cell{i});
                    plot(this.relScanTimes_cell{i},...
                        this.peak_dFF.firstSetNorm_scan_peak(start:stop),...
                        'o');
                    start = start + length(this.relScanTimes_cell{i});

                end
            
            end
            
            
            if dgr
                title('Peak Response Over Time');
                axis([this.relScanTimes(1)-1,this.relScanTimes(end)+1,-0.1,...
                    max(this.peak_dGR.firstSetNorm_scan_peak)*1.1]);
                xlabel('Time (min.)');
                ylabel('Peak dG/R (norm to first scan set)');
                
                meanPeaks = plot(cellfun(@mean,this.relScanTimes_cell),...
                    this.peak_dGR.firstSetNorm_set_peak,...
                    '-kO','MarkerSize',10);          
            else
                title('Peak Response Over Time');
                axis([this.relScanTimes(1)-1,this.relScanTimes(end)+1,-0.1,...
                    max(this.peak_dFF.firstSetNorm_scan_peak)*1.1]);
                xlabel('Time (min.)');
                ylabel('Peak dF/F (norm to first scan set)');
            
                meanPeaks = plot(cellfun(@mean,this.relScanTimes_cell),...
                    this.peak_dFF.firstSetNorm_set_peak,...
                    '-kO','MarkerSize',10);
            end
                                    
            legend(meanPeaks,'Linescan Set Average');

            hold off
            
            %now "unnormalized" dF/F
            
            varargout{2} = figure();
            hold on
            x_max = max(this.relScanTimes);
            
            if dgr
                first_mean_peak = this.peak_dGR.norm_set_peak(1);
            else
                first_mean_peak = this.peak_dFF.norm_set_peak(1);
            end
            
            plot([0,x_max+1],[first_mean_peak,first_mean_peak],'k--');
            plot([0,x_max+1],[0,0],'k-');
            
            start = 1;           
            stop = 0;
            
            if dgr
                for i=1:this.analysisParams.numScanSets

                    stop = stop + length(this.relScanTimes_cell{i});

                    plot(this.relScanTimes_cell{i},...
                        this.peak_dGR.norm_scan_peak(start:stop),...
                        'o');

                    start = start + length(this.relScanTimes_cell{i});

                end
            else
                for i=1:this.analysisParams.numScanSets

                    stop = stop + length(this.relScanTimes_cell{i});

                    plot(this.relScanTimes_cell{i},...
                        this.peak_dFF.norm_scan_peak(start:stop),...
                        'o');

                    start = start + length(this.relScanTimes_cell{i});

                end
            end
            
            if dgr
                title('Peak Response Over Time');
                axis([this.relScanTimes(1)-1,this.relScanTimes(end)+1,-0.1,...
                    max(this.peak_dGR.norm_scan_peak)*1.1]);
                xlabel('Time (min.)');
                ylabel('Peak dG/R');
            
                meanPeaks = plot(cellfun(@mean,this.relScanTimes_cell),...
                    this.peak_dGR.norm_set_peak,...
                    '-kO','MarkerSize',10);

            else
                title('Peak Response Over Time');
                axis([this.relScanTimes(1)-1,this.relScanTimes(end)+1,-0.1,...
                    max(this.peak_dFF.norm_scan_peak)*1.1]);
                xlabel('Time (min.)');
                ylabel('Peak dF/F');
            
                meanPeaks = plot(cellfun(@mean,this.relScanTimes_cell),...
                    this.peak_dFF.norm_set_peak,...
                    '-kO','MarkerSize',10);
            end
          
            
            legend(meanPeaks,'Linescan Set Average');

            hold off
            
        end
        
        function [varargout] = plotRawVals_all(this)
            
            %This plots the RAW values at peaks and bases of all scans in
            %this bouton, with the mean for each set of linescans.
            
            varargout{1} = figure();
            hold on
            x_max = max(this.relScanTimes);
            
            first_set_peak = this.peak_dFF.raw_set_peak(1);
            
            plot([0,x_max+1],[first_set_peak,first_set_peak],'k--');
            plot([0,x_max+1],[0,0],'k-');
            
            plot(reshape(this.relScanTimes,this.scans{1}.numTrials,this.analysisParams.numScanSets),...
                reshape(this.peak_dFF.raw_scan_peak,...
                this.scans{1}.numTrials,this.analysisParams.numScanSets),'o');
            
            title('Peak Fluorescence Over Time');
            axis([this.relScanTimes(1)-1,this.relScanTimes(end)+1,-0.1,...
                max(this.peak_dFF.raw_scan_peak)*1.1]);
            xlabel('Time (min.)');
            ylabel('Peak F (raw)');
                        
            meanPeaks = plot(mean(reshape(this.relScanTimes,this.scans{1}.numTrials,...
                this.analysisParams.numScanSets)),this.peak_dFF.raw_set_peak,...
                '-kO','MarkerSize',10);
            
            legend(meanPeaks,'Linescan Set Average');

            hold off

            %now Bases
            
            varargout{2} = figure();
            hold on
            x_max = max(this.relScanTimes);
            
            first_set_base = this.peak_dFF.raw_set_base(1);
            plot([0,x_max+1],[first_set_base,first_set_base],'k--');
            plot([0,x_max+1],[0,0],'k-');
            
            plot(reshape(this.relScanTimes,this.scans{1}.numTrials,this.analysisParams.numScanSets),...
                reshape(this.peak_dFF.raw_scan_base,...
                this.scans{1}.numTrials,this.analysisParams.numScanSets),'o');
            
            title('Base Fluorescence Over Time');
            axis([this.relScanTimes(1)-1,this.relScanTimes(end)+1,-0.1,...
                max(this.peak_dFF.raw_scan_base)*1.1]);
            xlabel('Time (min.)');
            ylabel('Base F (raw)');
                        
            meanPeaks = plot(mean(reshape(this.relScanTimes,this.scans{1}.numTrials,...
                this.analysisParams.numScanSets)),this.peak_dFF.raw_set_base,...
                '-kO','MarkerSize',10);
            
            legend(meanPeaks,'Linescan Set Average');

            hold off
            
        end
        
        %ROUTINES
        function analyze(this)
            
            display (['  -- ',this.name,' Analyzing'])
            for i=1:length(this.scans)
                this.scans{i}.analyze
            end
            display (['  -- ',this.name,' Analyzed'])            
            fprintf (['  -- ',this.name])
            cprintf('*blue',' pullPeaks')
            this.pullPeaks;
            cprintf('*black',' Saving')
            this.save
            fprintf('\n')
            fprintf('\n')
            
            
        end
        
        function visualize(this,whatPlot,saveMe)
            
            single = 0;
            dgr = 0;
            
            if nargin<3
                saveMe = 0;
                if nargin<2
                    if this.analysisParams.dgr
                        whatPlot = 'triple dgr';
                    else
                        whatPlot = 'triple dff';
                    end
                end
            end
            
            if ischar(whatPlot)
                whatPlot = lower(whatPlot);

                switch whatPlot
                    case {'single','single dff','singledff','single_dff'}
                        single = 1;
                    case {'triple','triple dff','tripledff','triple_dff'}
                        single = 0;
                    case {'dgr','triple dgr','tripledgr','triple_dgr'}
                        dgr = 1;
                    case {'single dgr','single_dgr','singledgr'}
                        single = 1;
                        dgr = 1;
                    otherwise
                        warning('Unexpected entry. dF/F and Triple Peak used.')
                end
            end
            
            % plot raw scans
            rawScans = this.plot_raw_data;
            
            if saveMe
                savefig(rawScans,[this.location,'/rawScans']);
            end
            
            % plot smoothed scans (set average, +/- SEM)
            if dgr
                smoothScans = this.plot_mean_dGR;
                savefig(smoothScans,[this.location,'/meanSEM_bySet_tripleDGR']);
            else
                smoothScans = this.plot_mean_dFF;
                savefig(smoothScans,[this.location,'/meanSEM_bySet_tripleDFF']);
            end
            
            % plot peaks amplitudes over time (set average, not singles)
            if single
                if dgr
                    singleDGR = this.plotPeakAmps_sets(1,1);
                    savefig(singleDGR,[this.location,'/setAmps_singleDGR']);
                else
                    singleDFF = this.plotPeakAmps_sets(0,1);
                    savefig(singleDFF,[this.location,'/setAmps_singleDFF']);
                end
            else
                if dgr
                    tripleDGR = this.plotPeakAmps_sets(1);
                    savefig(tripleDGR,[this.location,'/setAmps_tripleDGR']);
                else
                    tripleDFF = this.plotPeakAmps_sets;
                    savefig(tripleDFF,[this.location,'/setAmps_tripleDFF']);
                end
            end
            
            %plot peak amplitudes over time (ALL TRIALS plus set averages)
            
            peaksOverTimeFig = this.plotPeakAmps_all(dgr);
            
            if saveMe
                savefig(peaksOverTimeFig,[this.location,'/allTrialAmps']);
            end
            
        end
        
        function explore(this)
            this.analyze;
            this.visualize;
            
            save(this);
        end
        
        %UPDATE
        function reset(this, listening, fullReset)
            
            if nargin<3
                fullReset = 0;
                if narging<2
                    listening = 0;
                end
            end
            
            if ~listening
                while (1)
                    fprintf('\n');
                    cprintf('*red',['Are you SURE you want to RESET ',this.name,'?']);

                    fprintf('\n');
                    target = input('  --> ','s');

                    if any([strcmpi(target,'no'),strcmpi(target,'n')...
                            strcmpi(target,'quit'),strcmpi(target,'q')])
                        display('quitting without saving');
                        return
                    elseif any([strcmpi(target,'yes'),strcmpi(target,'y')...
                            strcmpi(target,'continue'),strcmpi(target,'cont')])
                        break
                    else
                        display('Must answer with "Yes or No"');
                        continue
                    end
                end

                while (1)
                    fprintf('\n');
                    cprintf('*red','Reset XML data as well (this will add a lot of time)?');

                    fprintf('\n');
                    target = input('  --> ','s');

                    if any([strcmpi(target,'no'),strcmpi(target,'n')...
                            strcmpi(target,'quit'),strcmpi(target,'q')])
                        xmlReset = 0;
                        break
                    elseif any([strcmpi(target,'yes'),strcmpi(target,'y')...
                            strcmpi(target,'continue'),strcmpi(target,'cont')])
                        xmlReset = 1;
                        break
                    else
                        display('Must answer with "Yes or No"');
                        continue
                    end
                end
            end
            
            disp(['--- RESETTING ' this.name]);
            fprintf('\n')
            
            if ~listening
                for i=1:length(this.scans)
                    this.scans{i}.reset(1,xmlReset);
                end
            else
                notify(this,'Reset',broadcastState(fullReset));
            end
            
            delete([this.location '/*.mat'])
            delete([this.location '/*.fig'])
            
            this.peak_dFF = [];
            this.peak_dGR = [];
            this.initializeDefaultAnalysis;
            
            dgr=1;
            
            for i=1:this.analysisParams.numScanSets;
                dgr = dgr*isfield(this.scans{i}.red,'sum');
            end
            
            this.analysisParams.dgr = dgr;  % this should be OFF unless ALL 
                                 % linescans have dGR (individual linescans
                                 % have dgr capabilities, but you should 
                                 % write custom scripts if you want to do
                                 % dGR analysis with partial datasets)
        end
        
        function updateAnalysisSettings(this)            
            
            fprintf('\n');
            display('What do you want to modify?');
            fprintf('\n');
            params = fieldnames(this.analysisParams);
            for i=1:length(params)
                if strcmpi(params{i},'lineScanDirectory')
                    display(['    ',params{i},repmat(' ',1,20-length(params{i})),...
                        ':      [',num2str(size(this.analysisParams.lineScanDirectory,1)),...
                        'x',num2str(size(this.analysisParams.lineScanDirectory,2)),' struct]'])
                else
                    display(['    ',params{i},repmat(' ',1,20-length(params{i})),...
                        ':      ',num2str(this.analysisParams.(params{i}))])
                end
            end
            fprintf('\n');
            target = input('  --> ','s');
            
            if any([strcmpi(target,'no'),strcmpi(target,'n')...
                    strcmpi(target,'quit'),strcmpi(target,'q')])
                display('quitting without saving');
                return
            end
            
            switch target
                case 'lineScanDirectory'
                    warning('Cannot change "lineScanDirectory" this way.')
                    return
                case 'numScanSets'
                    prompt = {'Enter total number of linescans'};
                    defaultans = {num2str(this.analysisParams.isSingle)};
                case 'scanNumber'
                    warning('Cannot change "scanNumber" this way.')
                    return
                case 'isSingle'
                    prompt = {'Turn on single analysis? (1 for yes, 0 for no)'};
                    defaultans = {num2str(this.analysisParams.isSingle)};
                case 'smoothing'
                    prompt = {'Enter smoothing STD (in samples)'};
                    defaultans = {num2str(this.analysisParams.smoothing)};
                case 'dgr'
                    prompt = {'Turn on delta G/R analysis? (1 for yes, 0 for no)'};
                    defaultans = {num2str(this.analysisParams.dgr)};
                case 'norm_range'
                    prompt = {'Enter start of normalization range (in seconds)',...
                        'Enter end of normalization range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.norm_range(1)),...
                        num2str(this.analysisParams.norm_range(2))};
                case 'single_sub'
                    prompt = {'Enter start of single stimulus subtraction range (in seconds)',...
                        'Enter end of single stimulus subtraction range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.single_sub(1)),...
                        num2str(this.analysisParams.single_sub(2))};
                case 'triple_sub'
                    prompt = {'Enter start of triple stimulus subtraction range (in seconds)',...
                        'Enter end of triple stimulus subtraction range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.triple_sub(1)),...
                        num2str(this.analysisParams.triple_sub(2))};
                case 'single_peak'
                    prompt = {'Enter start of single stimulus peak range (in seconds)',...
                        'Enter end of single stimulus peak range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.single_peak(1)),...
                        num2str(this.analysisParams.single_peak(2))};
                case 'triple_peak'
                    prompt = {'Enter start of triple stimulus peak range (in seconds)',...
                        'Enter end of triple stimulus peak range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.triple_peak(1)),...
                        num2str(this.analysisParams.triple_peak(2))};
                otherwise
                    warning('That is not a thing!')
                    return
            end
                    
            dlg_title = ['Update Analysis Settings - ',target];
            num_lines = length(prompt);
            answer = inputdlg(prompt,dlg_title,num_lines,defaultans);
            
            tempParams = struct();
            
            switch target
                case 'numScanSets'
                    tempParams.numScanSets = str2double(answer{1});
                case 'isSingle'
                    tempParams.isSingle = str2double(answer{1});
                case 'smoothing'
                    tempParams.smoothing = str2double(answer{1});
                case 'dgr'
                    tempParams.dgr = str2double(answer{1});
                case 'norm_range'
                    tempParams.norm_range = [str2double(answer{1}),str2double(answer{2})];
                case 'single_sub'
                    tempParams.single_sub = [str2double(answer{1}),str2double(answer{2})];
                case 'triple_sub'
                    tempParams.triple_sub = [str2double(answer{1}),str2double(answer{2})];
                case 'single_peak'
                    tempParams.single_peak = [str2double(answer{1}),str2double(answer{2})];
                case 'triple_peak'
                    tempParams.triple_peak = [str2double(answer{1}),str2double(answer{2})];
            end
            
            fprintf('\n');
            display('New Set of Parameters:');
            fprintf('\n');
            params = fieldnames(this.analysisParams);
            for i=1:length(params)
                if strcmpi(params{i},'lineScanDirectory')
                    display(['    ',params{i},repmat(' ',1,20-length(params{i})),...
                        ':      [',num2str(size(this.analysisParams.lineScanDirectory,1)),...
                        'x',num2str(size(this.analysisParams.lineScanDirectory,2)),' struct]'])
                elseif strcmpi(params{i},target)
                    if (this.analysisParams.(params{i}) == tempParams.(params{i}))
                        cprintf('*black',['    ',params{i},repmat(' ',1,20-length(params{i})),...
                        ':      ',num2str(tempParams.(params{i})),'\n'])
                    else
                        cprintf('*red',['    ',params{i},repmat(' ',1,20-length(params{i})),...
                        ':      ',num2str(tempParams.(params{i})),'\n'])
                    end
                else
                    display(['    ',params{i},repmat(' ',1,20-length(params{i})),...
                        ':      ',num2str(this.analysisParams.(params{i}))])
                end

            end
            
            fprintf('\n');
            display('  Are you sure you want to continue? Y/N');
            cont = input('  --> ','s');
            
            if any([strcmpi(cont,'no'),strcmpi(cont,'n')...
                    strcmpi(cont,'quit'),strcmpi(cont,'q')])
                display('quitting without saving');
                return
            elseif any([strcmpi(cont,'yes'),strcmpi(cont,'y')])
                fprintf('\n');
                display('Saving new parameters...');
                
                bcState = 1;                    %turns on saving params in downstream linescans
                bcData = tempParams.(target);   %data to be saved
                bcType = target;                %name of parameter (string)
                
                notify(this,'ChangeParams',broadcastState(bcState,bcData,bcType));
                
                this.analysisParams.(target) = tempParams.(target);
%                display('Rerunning "explore" with new parameters...');

%                this.explore
            end

            
        end
        
        function save(this)
            bouton = this; %#ok<NASGU>
            save([this.location,'/',this.name,'.mat'],'bouton');
        end
        
        function listenHandles = restoreListeners(this,containerObj)
            
            listenHandles = cell(1,3);
            
            display(['   Restoring Listeners of Bouton ',this.name,' to Experiment ',containerObj.name])
            
            if isobject(containerObj)       %true when bouton is being put into 
                                            %array of another object like experiment, so we can listen
                listenHandles{1} = addlistener(containerObj,'Reset',@this.eventReset);
                listenHandles{2} = addlistener(containerObj,'SaveFigs',@this.eventSaveFigs);
                listenHandles{3} = addlistener(containerObj,'UpdateAnalysis',@this.eventUpdateAnalysis);
            end
            
            display(['   Restoring Listeners of Contained LineScans to Bouton ',this.name,'...'])
            
            for i=1:this.analysisParams.numScanSets
                this.scanListeners{i} = this.scans{i}.restoreListeners(this);
            end
            
            fprintf('\n')
            
        end
    end
    
    methods (Access = private)
        
        %Importing Functions
        function importNameAndLoc(this,path)
            [~, this.name] = fileparts(path);
            this.location = path;
        end
        
        function initializeDefaultAnalysis(this)
            
            this.stimTimes = [0.05,0.07,0.09];

            main_listing = dir([this.location,'/LineScan*']);

            this.analysisParams.lineScanDirectory = main_listing;
            this.analysisParams.numScanSets = size(main_listing,1);
            this.analysisParams.scanNumber = cell2mat(cellfun(@(x) str2double(x(end-2:end)),{main_listing.name},'UniformOutput',false));
            this.analysisParams.isSingle = 0;
            this.analysisParams.smoothing = 4;
            this.analysisParams.dgr = 1;        % this should be OFF unless ALL linescans have dGR
            this.analysisParams.norm_range = [0.075,0.09];
            this.analysisParams.triple_peak = [0.104,0.111];   
            this.analysisParams.triple_sub = [0.085,0.09];
            this.analysisParams.single_peak = [0.13,0.16];
            this.analysisParams.single_sub = [0.085,0.09];
            
            this.plottingParams.color_scheme = ...      
            [0.7, 0.7, 0.7;
            0, 0, 0;
            0.7, 0, 0;
            0, 0.7, 0;
            0, 0, 0.7;
            0.7, 0.7, 0;
            0, 0.7, 0.7;
            0.7, 0, 0.7];
            %Grey, Black, Red, Green, Blue, Yellow, Cyan, Magenta (starts
            %with Black using mod(i,7)+1)
                        
        end
        
        function importLineScans(this)
            
            this.scans = cell(1,this.analysisParams.numScanSets);
            
            for i=1:this.analysisParams.numScanSets
                
                str = sprintf('%.3d',this.analysisParams.scanNumber(i));
                sub_listing = dir([this.location,'/*',str]);
                subdirectory = [this.location,'/',sub_listing.name];

                this.scans{i} = lineScan(subdirectory, this);
                
            end
            
        end
        
        function importTimeData(this)
            
            this.relScanTimes = cell(1,this.analysisParams.numScanSets);
            
            for i=1:this.analysisParams.numScanSets
                this.relScanTimes{i} = this.scans{i}.globalScanTimes;
            end
            
            startTime = min(cellfun(@min,this.relScanTimes));
                        
            this.relScanTimes = cellfun(@(x) (1e5/60).*(x-startTime),...
                this.relScanTimes,'UniformOutput',0);
                       
            this.relSetTimes = cellfun(@mean,this.relScanTimes);
            
            temp = cellfun(@transpose,this.relScanTimes,'UniformOutput',false);
            
            this.relScanTimes_cell = temp;
            this.relScanTimes = [temp{:}];

        end

        %Plotting Functions
        function [varargout] = plot_mean_scans(this,dgr,category,colors_on)
            
            if nargin<4
                colors_on=1; %turn on rotating color schemes
                if nargin<3
                    category = 2; %0=normalized, 1 = unnorm, 2 = smoothed norm
                    if nargin<2
                        dgr = 0;    %default to dF/F
                    end
                end
            end
            
            scrsz = get(groot,'ScreenSize');
            varargout{1} = figure('Position',[1 1 scrsz(3)/2 scrsz(4)/2.55]);
                        
            if ~(category==1)
                if ~isfield(this.scans{1}.green,'smooth_norm')
                    
                    warning('May not have run smooth or normalize methods yet')
                    display('Run "bouton.analyze" with default parameters?')
                    abandon = input('>','s');
                    
                    if any([strcmpi(abandon,'no'),strcmpi(abandon,'n')...
                            strcmpi(abandon,'quit'),strcmpi(abandon,'q')])
                        display('quitting without saving');
                        close;
                        return
                    elseif any([strcmpi(abandon,'yes'),strcmpi(abandon,'y')])
                        fprintf('\n');
                        display('Running "bouton.analyze"...');
                        fprintf('\n');
                        this.analyze;
                    else
                        display('quitting without saving');
                        close;
                        return
                    end
                end
            end
                        
            num_scans = this.analysisParams.numScanSets;
            main_handles = struct();

            if dgr
                if category == 1    % unnorm
                    all_greenRed_sums = zeros(num_scans,length(this.scans{1}.time));
                    for i=1:num_scans
                        scan_name = ['scan',num2str(i)];
                        if colors_on %rotating color scheme
                            scale_color = this.plottingParams.color_scheme((mod(i,7)+1),:);
                        else
                            scale_color = [(i-1)*0.8/num_scans, (i-1)*0.8/num_scans, (i-1)*0.8/num_scans];
                        end
                        handle_name = [scan_name,'handle'];
                        main_handles.(handle_name) = shadedErrorBar(this.scans{i}.time,mean(this.scans{i}.greenRed.sum),this.scans{i}.greenRed.sem,{'Color',scale_color},1);
                        hold on
                        all_greenRed_sums(i,1:length(this.scans{i}.greenRed.sum)) = mean(this.scans{i}.greenRed.sum);
                    end
                        y_max = max(max(all_greenRed_sums));
                        y_min = min(min(all_greenRed_sums));

                elseif category == 2 % smooth

                    all_smoothGreenOverReds = zeros(num_scans,length(this.scans{1}.time));
                    for i=1:num_scans
                        scan_name = ['scan',num2str(i)];
                        if colors_on %rotating color scheme
                            scale_color = this.plottingParams.color_scheme((mod(i,7)+1),:);
                        else     %greyscale
                            scale_color = [(i-1)*0.8/num_scans, (i-1)*0.8/num_scans, (i-1)*0.8/num_scans];
                        end
                        handle_name = [scan_name,'handle'];
                        main_handles.(handle_name) = shadedErrorBar(this.scans{i}.time,this.scans{i}.greenRed.smooth_norm,this.scans{i}.greenRed.smooth_norm_sem,{'Color',scale_color},1);
                        hold on
                        all_smoothGreenOverReds(i,1:length(this.scans{i}.greenRed.smooth_norm)) = this.scans{i}.greenRed.smooth_norm;
                    end
                        y_max = max(max(all_smoothGreenOverReds));
                        y_min = min(min(all_smoothGreenOverReds));

                else % norm
                    all_greenRed_norms = zeros(num_scans,length(this.scans{1}.time));
                    for i=1:num_scans
                        scan_name = ['scan',num2str(i)];
                        if colors_on %rotating color scheme
                            scale_color = this.plottingParams.color_scheme((mod(i,7)+1),:);
                        else     %greyscale
                            scale_color = [(i-1)*0.8/num_scans, (i-1)*0.8/num_scans, (i-1)*0.8/num_scans];
                        end
                        handle_name = [scan_name,'handle'];
                        main_handles.(handle_name) = shadedErrorBar(this.scans{i}.time,this.scans{i}.greenRed.norm,this.scans{i}.greenRed.norm_sem,{'Color',scale_color},1);
                        hold on
                        all_greenRed_norms(i,1:length(this.scans{i}.greenRed.norm)) = this.scans{i}.greenRed.norm;
                    end
                        y_max = max(max(all_greenRed_norms));
                        y_min = min(min(all_greenRed_norms));
                end  
                
                
            else
                % dG/R turned off, just do dF/F
                if category == 1    % unnorm
                    all_green = zeros(num_scans,length(this.scans{1}.time));
                    for i=1:num_scans
                        scan_name = ['scan',num2str(i)];
                        if colors_on %rotating color scheme
                            scale_color = this.plottingParams.color_scheme((mod(i,7)+1),:);
                        else
                            scale_color = [(i-1)*0.8/num_scans, (i-1)*0.8/num_scans, (i-1)*0.8/num_scans];
                        end
                        handle_name = [scan_name,'handle'];
                        main_handles.(handle_name) = shadedErrorBar(this.scans{i}.time,mean(this.scans{i}.green.sum),this.scans{i}.green.sem,{'Color',scale_color},1);
                        hold on
                        all_green(i,1:length(this.scans{i}.green.sum)) = mean(this.scans{i}.green.sum);
                    end
                        y_max = max(max(all_green));
                        y_min = min(min(all_green));

                elseif category == 2 % smooth

                    all_smoothGreens = zeros(num_scans,length(this.scans{1}.time));
                    for i=1:num_scans
                        scan_name = ['scan',num2str(i)];
                        if colors_on %rotating color scheme
                            scale_color = this.plottingParams.color_scheme((mod(i,7)+1),:);
                        else     %greyscale
                            scale_color = [(i-1)*0.8/num_scans, (i-1)*0.8/num_scans, (i-1)*0.8/num_scans];
                        end
                        handle_name = [scan_name,'handle'];
                        main_handles.(handle_name) = shadedErrorBar(this.scans{i}.time,this.scans{i}.green.smooth_norm,this.scans{i}.green.smooth_norm_sem,{'Color',scale_color},1);
                        hold on
                        all_smoothGreens(i,1:length(this.scans{i}.green.smooth_norm)) = this.scans{i}.green.smooth_norm;
                    end
                        y_max = max(max(all_smoothGreens));
                        y_min = min(min(all_smoothGreens));

                else % norm
                    all_green = zeros(num_scans,length(this.scans{1}.time));
                    for i=1:num_scans
                        scan_name = ['scan',num2str(i)];
                        if colors_on %rotating color scheme
                            scale_color = this.plottingParams.color_scheme((mod(i,7)+1),:);
                        else     %greyscale
                            scale_color = [(i-1)*0.8/num_scans, (i-1)*0.8/num_scans, (i-1)*0.8/num_scans];
                        end
                        handle_name = [scan_name,'handle'];
                        main_handles.(handle_name) = shadedErrorBar(this.scans{i}.time,this.scans{i}.green.norm,this.scans{i}.green.norm_sem,{'Color',scale_color},1);
                        hold on
                        all_green(i,1:length(this.scans{i}.green.norm)) = this.scans{i}.green.norm;
                    end
                        y_max = max(max(all_green));
                        y_min = min(min(all_green));
                end
            end
            
            for i=1:length(this.stimTimes)
                plot([this.stimTimes(i),this.stimTimes(i)],[y_min, 1.1*y_max],'-k');
            end
            
            varargout{2} = main_handles;

            %now that basic comparison is done, format axes and labels

            x_max = max(this.scans{1}.time);

            if category == 1 %unnorm
                axis([0,1.01*x_max,0.9*y_min,1.2*(y_max-y_min)+y_min])
                title('Raw Fluorescence vs Time')
                if dgr
                    ylabel('G/R(t)')
                else
                    ylabel('F(t)')
                end
            else  %norm
                axis([0,1.01*x_max,y_min-0.05,1.2*y_max])
                if dgr
                    title('dG/R vs Time')
                    ylabel('dG/R')       
                else
                    title('dF/F vs Time')
                    ylabel('dF/F')
                end
                plot([0,1.01*x_max],[0,0],'--k')
            end
            
            xlabel('Time, seconds')

            legend_handles = zeros(1,num_scans);
            legend_names = cell(1,num_scans);
            
            for i=1:num_scans
                handle_name = ['scan',num2str(i),'handle'];
                legend_handles(i) = main_handles.(handle_name).patch;
                legend_names{i} = ['Scan Set ',num2str(i)];
            end 

            legend(legend_handles,legend_names);

            hold off

        end
        
        %Listener Callbacks
        function eventReset(this,eventCaller,eventData)
                        
            fullReset = eventData.bcState;
            listening = 1;
            
            this.reset(listening,fullReset);
        end
        
        function eventSaveFigs(this,eventCaller,eventData)

            saveMe = eventData.bcState;
            
            fprintf('\n')
            cprintf('*red',['  --- SAVING FIGURES ', this.name]);
            
            this.visualize('triple dff',saveMe);
            close all
            
            notify(this,'SaveFigs',broadcastState(saveMe));
        
        end
        
        function eventUpdateAnalysis(this,eventCaller,eventData)
            
            target = eventData.bcState;
            response = eventData.bcData;
            
            fprintf('\n')
            display(['  -Checking bouton ',this.name])
            fprintf('\n')
                        
            switch target
                case 'isSingle'
                    prompt = {'Turn on single analysis? (1 for yes, 0 for no)'};
                    defaultans = {num2str(this.analysisParams.isSingle)};
                case 'smoothing'
                    prompt = {'Enter smoothing STD (in samples)'};
                    defaultans = {num2str(this.analysisParams.smoothing)};
                case 'norm_range'
                    prompt = {'Enter start of normalization range (in seconds)',...
                        'Enter end of normalization range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.norm_range(1)),...
                        num2str(this.analysisParams.norm_range(2))};
                case 'dgr'
                    prompt = {'Turn on delta G over R analysis? (1 for yes, 0 for no)'};
                    defaultans = {num2str(this.analysisParams.dgr)};
                case 'single_sub'
                    prompt = {'Enter start of single stimulus subtraction range (in seconds)',...
                        'Enter end of single stimulus subtraction range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.single_sub(1)),...
                        num2str(this.analysisParams.single_sub(2))};
                case 'triple_sub'
                    prompt = {'Enter start of triple stimulus subtraction range (in seconds)',...
                        'Enter end of triple stimulus subtraction range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.triple_sub(1)),...
                        num2str(this.analysisParams.triple_sub(2))};
                case 'single_peak'
                    prompt = {'Enter start of single stimulus peak range (in seconds)',...
                        'Enter end of single stimulus peak range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.single_peak(1)),...
                        num2str(this.analysisParams.single_peak(2))};
                case 'triple_peak'
                    prompt = {'Enter start of triple stimulus peak range (in seconds)',...
                        'Enter end of triple stimulus peak range (in seconds)'};
                    defaultans = {num2str(this.analysisParams.triple_peak(1)),...
                        num2str(this.analysisParams.triple_peak(2))};
                otherwise
                    warning('That is not a thing!')
                    return
            end

            
            dlg_title = ['Update Analysis Settings - ',target];
            num_lines = length(prompt);
            
            if isnan(response)
                answer = inputdlg(prompt,dlg_title,num_lines,defaultans);
            elseif ~isnan(response)
                answer = {num2str(response)};
            end
            
            tempParams = struct();
            
            switch target
                case 'numScanSets'
                    tempParams.numScanSets = str2double(answer{1});
                case 'isSingle'
                    tempParams.isSingle = str2double(answer{1});
                case 'smoothing'
                    tempParams.smoothing = str2double(answer{1});
                case 'dgr'
                    tempParams.dgr = str2double(answer{1});
                case 'norm_range'
                    tempParams.norm_range = [str2double(answer{1}),str2double(answer{2})];
                case 'single_sub'
                    tempParams.single_sub = [str2double(answer{1}),str2double(answer{2})];
                case 'triple_sub'
                    tempParams.triple_sub = [str2double(answer{1}),str2double(answer{2})];
                case 'single_peak'
                    tempParams.single_peak = [str2double(answer{1}),str2double(answer{2})];
                case 'triple_peak'
                    tempParams.triple_peak = [str2double(answer{1}),str2double(answer{2})];
            end
            
            fprintf('\n');
            display('Saving new parameters...');

            bcState = 1;                    %turns on saving params in downstream linescans
            bcData = tempParams.(target);   %data to be saved
            bcType = target;                %name of parameter (string)

            notify(this,'ChangeParams',broadcastState(bcState,bcData,bcType));

            this.analysisParams.(target) = tempParams.(target);

            
        end
        
    end
    
end